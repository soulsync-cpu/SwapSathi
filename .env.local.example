import { Pool } from "pg";
import type { NextApiRequest, NextApiResponse } from "next";

const connectionString = process.env.DATABASE_URL;
if (!connectionString) {
  throw new Error("DATABASE_URL is not set in environment");
}

// Reuse pool across module reloads (Next.js / serverless friendly)
declare global {
  // eslint-disable-next-line no-var
  var __pgPool__: Pool | undefined;
}

const sslConfig = { rejectUnauthorized: false };

const pool: Pool = global.__pgPool__ ?? new Pool({
  connectionString,
  ssl: sslConfig,  npm install @prisma/client
  npm install -D prisma
});

if (!global.__pgPool__) {
  global.__pgPool__ = pool;
}

export async function query(text: string, params?: any[]) {
  return pool.query(text, params);
}

export default pool;

export async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === "GET") {
    try {
      const result = await query("SELECT id, email FROM users LIMIT 100");
      return res.status(200).json(result.rows);
    } catch (err) {
      console.error("DB query error:", err);
      return res.status(500).json({ error: "internal_server_error" });
    }
  }

  res.setHeader("Allow", ["GET"]);
  return res.status(405).end();
}

// Example environment variables (do NOT commit your real secrets).
// Create a file named .env.local and copy values there.

// Postgres / Neon connection string
// Format: postgres://<user>:<password>@<host>:<port>/<db>?ssl=true
DATABASE_URL=

// Optional shadow DB for Prisma migrations (recommended for CI/migrations)
// SHADOW_DATABASE_URL=
